// std/living.c - Base object for all living things (NPCs, players)
// Inherits from std/object and adds life-related properties

inherit "/std/object";

// Phase 1, Step 1a: HP and SDC variables
int hp;
int max_hp;
int sdc;              // Structural Damage Capacity
int max_sdc;

// Phase 1, Step 1b: MDC variables
int mdc;              // Mega-Damage Capacity (1 MDC = 100 SDC)
int max_mdc;

// Phase 1, Step 1c: Health type flag
int health_type;      // 0 = SDC creature (uses HP+SDC), 1 = MDC creature (uses MDC only)

// Phase 2, Step 3a: Creature size
int creature_size;    // 0=Tiny, 1=Small, 2=Medium, 3=Large, 4=Huge

// Introduction system - track who knows this character's name
mapping introduced_to;  // Maps object -> 1 when introduced (session-based)
mapping remembered_names; // Maps "player_name" -> timestamp (persistent)

// Position system - custom RP position string
string position_desc;   // Custom position for room descriptions (e.g., "is sitting by the fire.")

// Combat system - track combat state
object combat_target;    // Current enemy
int combat_round;        // Combat round counter
int attacks_this_round;  // Number of attacks used
int max_attacks;         // Max attacks per round
int combat_heartbeat_id; // Callout ID for combat rounds

// Other living attributes
int level;
string name;
string real_name;
string race_name;
mapping languages;
string primary_language;

// Experience and leveling system
int experience;           // Current experience points
int exp_to_level;         // XP needed for next level

// Lives system (Rifts style)
int lives;                // Current lives remaining
int max_lives;            // Maximum lives (starts 5, caps at 15)
string *scars;            // Array of scar descriptions from deaths

// Currency system
int universal_credits;    // Standard currency (UC)
int black_market_credits; // Black market currency (BMC)

// Action registry for add_action/enable_commands
private int commands_enabled;
private mapping actions;  // Maps verb -> ({ function, flags })
private string current_verb;  // The verb currently being processed

void create() {
    // Initialize base object fields directly
    // (not calling ::create() due to scope resolution bug in AMLP)
    // This initialization duplicates object.lpc but avoids infinite recursion
    
    // Base object init
    // (short_desc and long_desc not used in living, but inherited)
    
    // Living creature init - Phase 1, Step 1: Initialize health system
    hp = 10;
    max_hp = 10;
    sdc = 0;
    max_sdc = 0;
    mdc = 0;
    max_mdc = 0;
    health_type = 0;  // Default: SDC creature (HP+SDC)
    creature_size = 2;  // Phase 2, Step 3a: Default medium size
    level = 1;
    name = "creature";
    real_name = "";
    race_name = "";
    introduced_to = ([ ]);  // Initialize introduction tracking
    remembered_names = ([ ]); // Initialize persistent introduction storage
    position_desc = "is standing around.";  // Default position
    languages = ([ ]);
    primary_language = "";
    
    // Experience and leveling init
    experience = 0;
    exp_to_level = 1000;  // 1000 XP to level 2
    
    // Lives system init
    lives = 5;            // Start with 5 lives
    max_lives = 5;        // Max lives starts at 5
    scars = ({});         // No scars initially
    
    // Currency init
    universal_credits = 0;
    black_market_credits = 0;
    
    // Combat system init
    combat_target = 0;
    combat_round = 0;
    attacks_this_round = 0;
    max_attacks = 1;  // Default 1 attack per round
    combat_heartbeat_id = 0;
    
    // Action registry init
    commands_enabled = 0;
    actions = ([ ]);
    current_verb = "";
}

int query_hp() {
    return hp;
}

void set_hp(int new_hp) {
    hp = new_hp;
}

int query_max_hp() {
    return max_hp;
}

void set_max_hp(int new_max) {
    max_hp = new_max;
}

// Phase 1, Step 2a: SDC query functions
int query_sdc() {
    return sdc;
}

int query_max_sdc() {
    return max_sdc;
}

// Phase 1, Step 2b: MDC query functions and health type
int query_mdc() {
    return mdc;
}

int query_max_mdc() {
    return max_mdc;
}

int query_health_type() {
    return health_type;  // 0 = SDC creature, 1 = MDC creature
}

// Phase 1, Step 2c: Combined health query
// Returns total effective health in SDC equivalents for comparison
int query_total_health() {
    if (health_type == 1) {
        // MDC creature: 1 MDC = 100 SDC
        return mdc * 100;
    } else {
        // SDC creature: HP + SDC
        return hp + sdc;
    }
}

// Phase 1, Step 3a: SDC setter functions
void set_sdc(int new_sdc) {
    sdc = new_sdc;
    if (sdc < 0) sdc = 0;
    if (sdc > max_sdc) sdc = max_sdc;
}

void set_max_sdc(int new_max) {
    max_sdc = new_max;
    if (max_sdc < 0) max_sdc = 0;
}

// Phase 1, Step 3b: MDC setter functions and health type
void set_mdc(int new_mdc) {
    mdc = new_mdc;
    if (mdc < 0) mdc = 0;
    if (mdc > max_mdc) mdc = max_mdc;
}

void set_max_mdc(int new_max) {
    max_mdc = new_max;
    if (max_mdc < 0) max_mdc = 0;
}

void set_health_type(int type) {
    health_type = type;  // 0 = SDC, 1 = MDC
}

// Phase 1, Step 3c: Health initialization helper
// Sets up a creature's health system based on type
void init_health(int type, int hit_points, int struct_damage, int mega_damage) {
    health_type = type;
    
    if (type == 0) {
        // SDC creature
        max_hp = hit_points;
        hp = hit_points;
        max_sdc = struct_damage;
        sdc = struct_damage;
        max_mdc = 0;
        mdc = 0;
    } else {
        // MDC creature
        max_mdc = mega_damage;
        mdc = mega_damage;
        max_hp = 0;
        hp = 0;
        max_sdc = 0;
        sdc = 0;
    }
}

// Phase 1, Step 4a / Phase 3, Step 1: Take damage function (handles armor, MDC/SDC/HP)
// damage_type: 0 = SDC damage, 1 = MDC damage
// Returns 1 if creature dies, 0 if still alive
int take_damage(int amount, int damage_type) {
    if (amount <= 0) return 0;
    
    int original_damage = amount;
    
    // Phase 3, Step 1a: Check for worn armor first (body armor protects against most damage)
    mapping equipped = query_equipped();
    object body_armor = 0;
    
    if (equipped && equipped["body"]) {
        body_armor = equipped["body"];
    }
    
    if (body_armor) {
        int is_mdc_armor = body_armor->query_property("is_mdc_armor");
        
        // Phase 3, Step 1b: Armor absorbs damage
        if (is_mdc_armor && damage_type == 1) {
            // MDC armor vs MDC damage
            if (!body_armor->is_armor_broken()) {
                // Armor absorbs the damage
                body_armor->damage_armor(amount);
                
                if (body_armor->is_armor_broken()) {
                    // Phase 3, Step 1c: Armor just broke!
                    tell_object(this_object(), "Your armor shatters under the impact!\n");
                }
                
                return 0;  // Armor absorbed all damage
            }
            // If armor is broken, damage passes through
        } else if (!is_mdc_armor && damage_type == 0) {
            // SDC armor vs SDC damage
            if (!body_armor->is_armor_broken()) {
                int armor_rating = body_armor->query_armor_rating();
                
                // AR provides chance to deflect/reduce damage
                if (armor_rating > 0) {
                    // Simple damage reduction: AR reduces damage by percentage
                    int reduction = (amount * armor_rating) / 100;
                    if (reduction > amount / 2) reduction = amount / 2;  // Cap at 50%
                    amount -= reduction;
                }
                
                // Armor takes some of the damage
                int armor_damage_taken = (original_damage - amount);
                if (armor_damage_taken > 0) {
                    body_armor->damage_armor(armor_damage_taken);
                    
                    if (body_armor->is_armor_broken()) {
                        tell_object(this_object(), "Your armor falls apart!\n");
                    }
                }
            }
        } else if (is_mdc_armor && damage_type == 0) {
            // SDC damage to MDC armor - no effect on armor or wearer
            return 0;
        } else if (!is_mdc_armor && damage_type == 1) {
            // MDC damage vs SDC armor - armor provides no protection
            // Damage passes through, armor is destroyed
            body_armor->damage_armor(99999);  // Instantly destroy SDC armor
            tell_object(this_object(), "Your armor is completely destroyed by the mega-damage!\n");
            // Damage continues to creature below
        }
    }
    
    // Apply remaining damage to creature
    if (health_type == 1) {
        // MDC creature
        if (damage_type == 1) {
            // MDC damage to MDC creature
            mdc -= amount;
            if (mdc < 0) mdc = 0;
        } else {
            // SDC damage to MDC creature - no effect!
            // SDC weapons cannot harm MDC creatures
            return 0;
        }
    } else {
        // SDC creature
        if (damage_type == 1) {
            // MDC damage to SDC creature - devastating!
            // 1 MDC = 100 SDC, instantly kills most SDC creatures
            int sdc_damage = amount * 100;
            
            // Apply to SDC first
            if (sdc > 0) {
                if (sdc >= sdc_damage) {
                    sdc -= sdc_damage;
                    sdc_damage = 0;
                } else {
                    sdc_damage -= sdc;
                    sdc = 0;
                }
            }
            
            // Overflow to HP
            if (sdc_damage > 0) {
                hp -= sdc_damage;
                if (hp < 0) hp = 0;
            }
        } else {
            // SDC damage to SDC creature
            // Apply to SDC first
            if (sdc > 0) {
                if (sdc >= amount) {
                    sdc -= amount;
                } else {
                    amount -= sdc;
                    sdc = 0;
                    // Overflow to HP
                    hp -= amount;
                    if (hp < 0) hp = 0;
                }
            } else {
                // No SDC left, apply to HP
                hp -= amount;
                if (hp < 0) hp = 0;
            }
        }
    }
    
    // Check if creature died
    if (!is_alive()) {
        return 1;
    }
    
    return 0;
}

// Phase 1, Step 4b: Heal damage function
// heal_type: 0 = normal healing (HP+SDC), 1 = MDC repair
void heal_damage(int amount, int heal_type) {
    if (amount <= 0) return;
    
    if (health_type == 1) {
        // MDC creature - only MDC repair works
        if (heal_type == 1) {
            mdc += amount;
            if (mdc > max_mdc) mdc = max_mdc;
        }
    } else {
        // SDC creature - normal healing
        if (heal_type == 0) {
            // Heal HP first
            if (hp < max_hp) {
                int hp_needed = max_hp - hp;
                if (amount <= hp_needed) {
                    hp += amount;
                    amount = 0;
                } else {
                    hp = max_hp;
                    amount -= hp_needed;
                }
            }
            
            // Overflow to SDC
            if (amount > 0 && sdc < max_sdc) {
                sdc += amount;
                if (sdc > max_sdc) sdc = max_sdc;
            }
        }
    }
}

// Phase 1, Step 4c: Status check functions
int is_alive() {
    if (health_type == 1) {
        return mdc > 0;
    } else {
        return hp > 0;  // Character dies when HP reaches 0
    }
}

int is_wounded() {
    if (health_type == 1) {
        return mdc < max_mdc;
    } else {
        return (hp < max_hp || sdc < max_sdc);
    }
}

// Get health percentage (0-100)
int query_health_percent() {
    if (health_type == 1) {
        if (max_mdc <= 0) return 100;
        return (mdc * 100) / max_mdc;
    } else {
        int total = max_hp + max_sdc;
        if (total <= 0) return 100;
        int current = hp + sdc;
        return (current * 100) / total;
    }
}

// Get health status string
string query_health_status() {
    int percent = query_health_percent();
    
    if (percent >= 100) return "perfect";
    if (percent >= 90) return "slightly wounded";
    if (percent >= 75) return "wounded";
    if (percent >= 50) return "badly wounded";
    if (percent >= 25) return "critically wounded";
    if (percent > 0) return "near death";
    return "dead";
}

// Phase 2, Step 3b: Creature size query/set functions
int query_creature_size() {
    return creature_size;
}

void set_creature_size(int s) {
    if (s < 0) s = 0;
    if (s > 4) s = 4;
    creature_size = s;
}

string query_creature_size_name() {
    string *size_names = ({ "tiny", "small", "medium", "large", "huge" });
    if (creature_size >= 0 && creature_size < sizeof(size_names)) {
        return size_names[creature_size];
    }
    return "medium";
}

// Phase 2, Step 3c: Size compatibility check for armor
// Returns 1 if armor can be worn, 0 if size mismatch
int can_wear_size(object armor) {
    if (!armor) return 0;
    
    int armor_size = armor->query_size();
    
    // Exact size match is always OK
    if (armor_size == creature_size) return 1;
    
    // One size difference might work with penalties
    // (Future: implement adjustment penalties)
    if (armor_size == creature_size - 1 || armor_size == creature_size + 1) {
        return 0;  // For now, require exact match
    }
    
    return 0;  // Size mismatch
}

// Phase 4, Step 2a/2b: Override query_short to check for appearance-modifying armor
string query_short() {
    mapping equipped = query_equipped();
    object body_armor;
    
    // Phase 4, Step 2a: Check for worn armor with appearance override
    if (equipped && equipped["body"]) {
        body_armor = equipped["body"];
        
        if (function_exists("query_property", body_armor)) {
            string appearance = body_armor->query_property("appearance_override");
            
            if (appearance && appearance != "") {
                // Phase 4, Step 2b: Return modified description
                return appearance;
            }
        }
    }
    
    // Phase 4, Step 2c: Check for cloak/back slot (secondary appearance layer)
    if (equipped && equipped["back"]) {
        object cloak = equipped["back"];
        
        if (function_exists("query_property", cloak)) {
            string appearance = cloak->query_property("appearance_override");
            
            if (appearance && appearance != "") {
                return appearance;
            }
        }
    }
    
    // No appearance override, return default (race-based)
    string race_name = query_race_name();
    
    if (race_name && race_name != "") {
        return race_name;
    }
    
    return name;  // Fallback to name
}

int query_level() {
    return level;
}

void set_level(int new_level) {
    level = new_level;
}

string query_name() {
    return name;
}

void set_name(string new_name) {
    name = new_name;
}

void set_real_name(string new_name) {
    real_name = new_name;
}

string query_real_name() {
    return real_name;
string query_race() {
    return race_name;
}

void set_race(string r) {
    race_name = r;
}

// Get true race (for detecting shapeshifted/disguised creatures)
string query_true_race() {
    string true_race = query_property("true_race");
    if (true_race) {
        return true_race;
    }
    return race_name;  // No disguise, return actual race
}

//=============================================================================
// Introduction System
//=============================================================================

// Introduce yourself to another person
void introduce_to(object ob) {
    if (!ob || !living(ob)) return;
    
    if (!introduced_to) introduced_to = ([ ]);
    introduced_to[ob] = 1;
    
    // Mutual introduction - they learn our name too
    if (function_exists("set_introduced", ob)) {
        ob->set_introduced(this_object());
    }
}

// Mark that someone knows us (called by their introduce_to)
void set_introduced(object ob) {
    if (!ob) return;
    if (!introduced_to) introduced_to = ([ ]);
    
    // Session memory
    introduced_to[ob] = 1;
    
    // Persistent memory - store by name
    string name = ob->query_real_name();
    if (!name || name == "") name = ob->query_name();
    if (name && name != "") {
        if (!remembered_names) remembered_names = ([ ]);
        remembered_names[name] = time();
    }
}

// Check if we've introduced ourselves to someone
int query_introduced(object ob) {
    if (!ob) return 0;
    
    // Check session memory first (fastest)
    if (introduced_to && introduced_to[ob]) return 1;
    
    // Check persistent memory
    if (remembered_names) {
        string name = ob->query_real_name();
        if (!name || name == "") name = ob->query_name();
        if (name && remembered_names[name]) return 1;
    }
    
    return 0;
}

// Get the name that an observer sees for this character
// Returns actual name if introduced or if observer is admin/wizard
// Otherwise returns race description like "a human" or "an elf"
string query_introduction_name(object observer) {
    // Wizards and admins always see real names
    if (observer && function_exists("query_wizard_level", observer)) {
        if (observer->query_wizard_level() > 0) {
            string n = query_real_name();
            if (!n || n == "") n = query_name();
            return n;
        }
    }
    
    // Check if introduced
    if (observer && introduced_to && introduced_to[observer]) {
        string n = query_real_name();
        if (!n || n == "") n = query_name();
        return n;
    }
    
    // Not introduced - show race description
    string race = query_race();
    if (!race || race == "") race = "creature";
    
    // Add article (a/an) based on first letter
    string first = race[0..0];
    string article = "a";
    if (first == "a" || first == "e" || first == "i" || first == "o" || first == "u" ||
        first == "A" || first == "E" || first == "I" || first == "O" || first == "U") {
        article = "an";
    }
    
    return article + " " + race;
}

/**
 * query_remembered_names - Return persistent introduction mapping
 */
mapping query_remembered_names() {
    if (!remembered_names) remembered_names = ([ ]);
    return remembered_names;
}

/**
 * add_remembered_name - Persistently remember someone
 * @param name The real name of the person to remember
 */
void add_remembered_name(string name) {
    if (!name || name == "") return;
    if (!remembered_names) remembered_names = ([ ]);
    remembered_names[name] = time();
}

/**
 * remove_remembered_name - Forget someone permanently
 * @param name The real name to forget
 */
void remove_remembered_name(string name) {
    if (!name || !remembered_names) return;
    map_delete(remembered_names, name);
}

/**
 * sync_introductions - Sync session and persistent introductions
 * Call this on login to rebuild introduced_to from remembered_names
 */
void sync_introductions() {
    if (!remembered_names || !sizeof(remembered_names)) return;
    if (!introduced_to) introduced_to = ([ ]);
    
    // For each remembered name, find the live object if online
    foreach(string name, int timestamp in remembered_names) {
        object ob = find_player(name);
        if (ob && living(ob)) {
            introduced_to[ob] = 1;
        }
    }
}

/**
 * broadcast_action - Send observer-specific messages to room
 * @param actor_msg Message shown to the actor (can be 0 to skip)
 * @param others_template Template for others, use $N for actor name
 * @param exclude Array of objects to exclude from broadcast
 */
void broadcast_action(string actor_msg, string others_template, object *exclude) {
    object env = environment();
    if (!env) return;
    
    // Initialize exclude array
    if (!exclude) exclude = ({ });
    
    // Message to actor
    if (actor_msg && actor_msg != "") {
        tell_object(this_object(), actor_msg);
    }
    
    // Messages to others in room
    object *inv = all_inventory(env);
    foreach(object ob in inv) {
        // Skip non-living, excluded, and actor
        if (!living(ob)) continue;
        if (member_array(ob, exclude) != -1) continue;
        if (ob == this_object()) continue;
        
        // Get actor name as seen by this observer
        string actor_name = query_introduction_name(ob);
        
        // Replace $N with observer-specific name
        string msg = replace_string(others_template, "$N", actor_name);
        tell_object(ob, msg);
    }
}

/**
 * broadcast_action_pair - Broadcast action involving actor and target
 * @param actor_msg Message to actor
 * @param target_msg_template Message to target, use $N for actor name
 * @param others_template Message to others, use $N for actor, $T for target
 * @param target The target object
 */
void broadcast_action_pair(string actor_msg, string target_msg_template, 
                           string others_template, object target) {
    object env = environment();
    if (!env) return;
    
    // Message to actor
    if (actor_msg && actor_msg != "") {
        tell_object(this_object(), actor_msg);
    }
    
    // Message to target
    if (target && target_msg_template && target_msg_template != "") {
        string actor_name = query_introduction_name(target);
        string msg = replace_string(target_msg_template, "$N", actor_name);
        tell_object(target, msg);
    }
    
    // Messages to others
    object *inv = all_inventory(env);
    foreach(object ob in inv) {
        if (!living(ob)) continue;
        if (ob == this_object() || ob == target) continue;
        
        // Get names as seen by this observer
        string actor_name = query_introduction_name(ob);
        string target_name = target ? target->query_introduction_name(ob) : "someone";
        
        // Replace $N and $T
        string msg = replace_string(others_template, "$N", actor_name);
        msg = replace_string(msg, "$T", target_name);
        tell_object(ob, msg);
    }
}

/**
 * announce_arrival - Broadcast arrival message to room
 * @param direction Direction player arrived from (e.g., "south", "north")
 */
void announce_arrival(string direction) {
    object env = environment();
    if (!env) return;
    
    object *inv = all_inventory(env);
    foreach(object ob in inv) {
        if (!living(ob) || ob == this_object()) continue;
        
        // Get name as seen by this observer
        string arrival_name = query_introduction_name(ob);
        
        // Build message
        string msg;
        if (direction && direction != "") {
            msg = arrival_name + " arrives from the " + direction + ".\\n";
        } else {
            msg = arrival_name + " arrives.\\n";
        }
        
        tell_object(ob, msg);
    }
}

/**
 * announce_departure - Broadcast departure message to room
 * @param direction Direction player is going (e.g., "north", "south")
 */
void announce_departure(string direction) {
    object env = environment();
    if (!env) return;
    
    object *inv = all_inventory(env);
    foreach(object ob in inv) {
        if (!living(ob) || ob == this_object()) continue;
        
        // Get name as seen by this observer
        string depart_name = query_introduction_name(ob);
        
        // Build message
        string msg;
        if (direction && direction != "") {
            msg = depart_name + " leaves " + direction + ".\\n";
        } else {
            msg = depart_name + " leaves.\\n";
        }
        
        tell_object(ob, msg);
    }
}

//=============================================================================
// Position System (for RP)
//=============================================================================

// Set custom position description
void set_position(string pos) {
    if (!pos || pos == "") {
        position_desc = "is standing around.";  // Reset to default
    } else {
        position_desc = pos;
    }
}

// Get position description
string query_position() {
    return position_desc ? position_desc : "is standing around.";
}

// Reset position to default (called on movement, combat, etc.)
void reset_position() {
    position_desc = "is standing around.";
}

void add_language(string lang, int proficiency) {
    if (!languages) languages = ([ ]);
    languages[lang] = proficiency;
}

mapping query_languages() {
    return languages ? languages : ([ ]);
}

void set_primary_language(string lang) {
    primary_language = lang;
}

string query_primary_language() {
    return primary_language;
}

// Get capitalized name for display
string query_cap_name() {
    string n;
    
    // Try real name first
    if (real_name && real_name != "") {
        n = real_name;
    } else if (name && name != "") {
        n = name;
    } else {
        n = "someone";
    }
    
    // Capitalize first letter
    if (sizeof(n) > 0) {
        return upper_case(n[0..0]) + n[1..];
    }
    
    return n;
}

// Get race name for query_race_name()
string query_race_name() {
    return race_name ? race_name : "unknown";
}

// Query stats (basic default implementation)
// Player.lpc may override this with actual character stats
int query_stat(string stat) {
    // Return default stats for NPCs/basic living things
    // Player.lpc should override this
    stat = upper_case(stat);
    
    switch (stat) {
        case "IQ": return 10;
        case "ME": return 10;
        case "MA": return 10;
        case "PS": return 10 + (level / 2);  // Slightly stronger with level
        case "PP": return 10 + (level / 2);  // Slightly more agile with level
        case "PE": return 10 + (level / 2) ;  // More endurance with level
        case "PB": return 10;
        case "SPD": return 10;
        default: return 10;
    }
}

// Death handler
void die(object killer) {
    string death_msg;
    
    if (killer) {
        death_msg = query_cap_name() + " has been slain by " + killer->query_cap_name() + "!\n";
    } else {
        death_msg = query_cap_name() + " has died!\n";
    }
    
    tell_room(environment(this_object()), death_msg);
    
    // For NPCs, destruct them
    if (!interactive(this_object())) {
        // Drop inventory
        object *inv = all_inventory(this_object());
        foreach (object item : inv) {
            if (item) {
                item->move(environment(this_object()));
            }
        }
        
        // Remove from game after 2 seconds
        call_out("remove_corpse", 2);
    } else {
        // For players, handle respawn
        tell_object(this_object(), "\nYou have died!\n\n");
        tell_object(this_object(), "Respawning...\n");
        
        // Restore health
        set_hp(query_max_hp());
        set_sdc(query_max_sdc());
        
        // Move to respawn location
        object respawn = load_object("/domains/start/void");
        if (respawn) {
            move(respawn);
            tell_object(this_object(), "\nYou awaken in a strange place...\n\n");
            call_other(this_object(), "cmd_look", "");
        }
    }
}

// Remove corpse (for NPCs)
void remove_corpse() {
    if (this_object()) {
        tell_room(environment(this_object()), 
                  "The corpse of " + query_cap_name() + " fades away.\n");
        destruct(this_object());
    }
}

//=============================================================================
// Action Registry System (add_action/enable_commands)
//=============================================================================

// Enable command processing for this object
void enable_commands() {
    commands_enabled = 1;
}

// Disable command processing for this object
void disable_commands() {
    commands_enabled = 0;
}

// Check if commands are enabled
int query_commands_enabled() {
    return commands_enabled;
}

// Add an action (register a function to handle specific verbs)
// Usage: add_action("function_name", "verb")
//        add_action("function_name") // Matches all verbs, function gets full command
void add_action(string func, string verb) {
    if (!actions) actions = ([ ]);
    
    if (!verb || verb == "") {
        // No verb means match all commands
        actions[""] = ({ func, 1 }); // Flag 1 = catch-all
    } else {
        actions[verb] = ({ func, 0 }); // Flag 0 = specific verb
    }
}

// Remove an action
void remove_action(string verb) {
    if (actions && verb) {
        map_delete(actions, verb);
    }
}

// Query all actions
mapping query_actions() {
    return actions ? actions : ([ ]);
}

// Get the verb currently being processed
string query_verb() {
    return current_verb;
}

// Set the current verb (called by command daemon during dispatch)
void set_verb(string verb) {
    current_verb = verb;
}

// Try to execute an action for a given command
// Returns 1 if an action was found and executed, 0 otherwise
int try_action(string verb, string args) {
    if (!commands_enabled || !actions) {
        return 0;
    }
    
    mixed action_data;
    string func;
    int is_catchall;
    
    // First try exact verb match
    if (actions[verb]) {
        action_data = actions[verb];
        func = action_data[0];
        is_catchall = action_data[1];
        
        // Set current verb for query_verb()
        current_verb = verb;
        
        // Call the function
        if (function_exists(func, this_object())) {
            int result = call_other(this_object(), func, args);
            current_verb = "";
            return result;
        }
    }
    
    // Try catch-all action (verb = "")
    if (actions[""]) {
        action_data = actions[""];
        func = action_data[0];
        
        // For catch-all, pass the full command including verb
        current_verb = verb;
        string full_cmd = verb;
        if (args && args != "") {
            full_cmd += " " + args;
        }
        
        if (function_exists(func, this_object())) {
            int result = call_other(this_object(), func, full_cmd);
            current_verb = "";
            return result;
        }
    }
    
    current_verb = "";
    return 0;
}
//=============================================================================
// Combat System
//=============================================================================

// Get current combat target
object query_combat_target() {
    return combat_target;
}

// Set combat target (starts combat)
void set_combat_target(object target) {
    combat_target = target;
    
    if (target) {
        // Start combat heartbeat if not already running
        if (!combat_heartbeat_id) {
            combat_round = 1;
            attacks_this_round = 0;
            combat_heartbeat_id = call_out("combat_heartbeat", 3);  // 3 second rounds
        }
    } else {
        // End combat
        if (combat_heartbeat_id) {
            remove_call_out(combat_heartbeat_id);
            combat_heartbeat_id = 0;
        }
        combat_round = 0;
        attacks_this_round = 0;
    }
}

// Check if in combat
int in_combat() {
    return combat_target && living(combat_target) ? 1 : 0;
}

// Combat heartbeat - called every round
void combat_heartbeat() {
    combat_heartbeat_id = 0;
    
    // Check if still in combat
    if (!combat_target || !living(combat_target)) {
        set_combat_target(0);
        return;
    }
    
    // Check if target is in same room
    if (environment(this_object()) != environment(combat_target)) {
        tell_object(this_object(), "Your target has fled!\n");
        set_combat_target(0);
        return;
    }
    
    // Check if either combatant is dead
    if (!is_alive() || !combat_target->is_alive()) {
        set_combat_target(0);
        return;
    }
    
    // Increment round
    combat_round++;
    attacks_this_round = 0;
    
    // Auto-attack if not a player (NPCs auto-attack)
    if (!interactive(this_object())) {
        perform_attack(combat_target);
    }
    
    // Schedule next heartbeat
    combat_heartbeat_id = call_out("combat_heartbeat", 3);
}

// Perform a combat attack
int perform_attack(object target) {
    if (!target || !living(target)) {
        return 0;
    }
    
    // Check if we have attacks remaining
    if (attacks_this_round >= max_attacks) {
        tell_object(this_object(), "You have no attacks remaining this round.\n");
        return 0;
    }
    
    attacks_this_round++;
    
    // Roll to hit (1d20 + bonuses)
    int roll = random(20) + 1;
    int strike_bonus = query_strike_bonus();
    int total = roll + strike_bonus;
    
    // Target number is 8 (base difficulty)
    int target_number = 8;
    
    // Critical hit
    if (roll == 20) {
        int damage = calculate_damage() * 2;
        apply_attack_damage(target, damage, 1);  // 1 = critical
        return 1;
    }
    
    // Critical miss
    if (roll == 1) {
        tell_object(this_object(), "You fumble your attack!\n");
        tell_room(environment(this_object()), 
                  query_cap_name() + " fumbles an attack!\n", 
                  ({ this_object() }));
        return 1;
    }
    
    // Check if hit
    if (total < target_number) {
        tell_object(this_object(), 
                    "You swing at " + target->query_cap_name() + " but miss! " +
                    "(Rolled " + roll + "+" + strike_bonus + "=" + total + " vs " + target_number + ")\n");
        tell_object(target,
                    query_cap_name() + " swings at you but misses!\n");
        tell_room(environment(this_object()),
                  query_cap_name() + " swings at " + target->query_cap_name() + " but misses!\n",
                  ({ this_object(), target }));
        return 1;
    }
    
    // Hit! Calculate damage
    int damage = calculate_damage();
    apply_attack_damage(target, damage, 0);  // 0 = normal hit
    
    return 1;
}

// Calculate strike bonus
int query_strike_bonus() {
    int bonus = 0;
    
    // Add PP bonus (dexterity)
    int pp = query_stat("PP");
    if (pp > 15) {
        bonus += (pp - 15) / 3;
    }
    
    // Add level bonus
    bonus += level / 4;
    
    // Check for weapon bonuses
    object weapon = query_wielded();
    if (weapon && function_exists("query_strike_bonus", weapon)) {
        bonus += weapon->query_strike_bonus();
    }
    
    return bonus;
}

// Calculate damage
int calculate_damage() {
    int damage;
    int dice, sides;
    
    // Check for wielded weapon
    object weapon = query_wielded();
    if (weapon && function_exists("query_damage", weapon)) {
        dice = weapon->query_damage_dice();
        sides = weapon->query_damage_sides();
    } else {
        // Bare hands - 1d4
        dice = 1;
        sides = 4;
    }
    
    // Roll damage
    damage = 0;
    for (int i = 0; i < dice; i++) {
        damage += random(sides) + 1;
    }
    
    // Add PS bonus for melee
    int ps = query_stat("PS");
    if (ps > 15) {
        damage += (ps - 15) / 3 + 1;
    }
    
    return damage > 0 ? damage : 1;
}

// Apply damage to target
void apply_attack_damage(object target, int damage, int is_critical) {
    string attacker_name = query_cap_name();
    string target_name = target->query_cap_name();
    
    if (is_critical) {
        tell_object(this_object(),
                    "CRITICAL HIT! You strike " + 
                    target_name + " for " + damage + " damage!\n");
        tell_object(target,
                    "CRITICAL HIT! " +
                    attacker_name + " strikes you for " + damage + " damage!\n");
        tell_room(environment(this_object()),
                  "CRITICAL HIT! " +
                  attacker_name + " strikes " + target_name + " for " + damage + " damage!\n",
                  ({ this_object(), target }));
    } else {
        tell_object(this_object(),
                    "You strike " + target_name + " for " + damage + " damage!\n");
        tell_object(target,
                    attacker_name + " strikes you for " + damage + " damage!\n");
        tell_room(environment(this_object()),
                  attacker_name + " strikes " + target_name + " for " + damage + " damage!\n",
                  ({ this_object(), target }));
    }
    
    // Apply damage (SDC damage type = 0)
    int killed = target->take_damage(damage, 0);
    
    if (killed) {
        tell_object(this_object(),
                    "\n>>> " + target_name + " has been defeated! <<<\n\n");
        tell_room(environment(this_object()),
                  "\n>>> " + target_name + " has been defeated! <<<\n\n",
                  ({ this_object() }));
        
        // End combat for both
        set_combat_target(0);
        if (function_exists("set_combat_target", target)) {
            target->set_combat_target(0);
        }
        
        // Handle death
        if (function_exists("die", target)) {
            target->die(this_object());
        }
    }
}

// Get combat status string
string query_combat_status() {
    if (!in_combat()) {
        return "You are not in combat.\n";
    }
    
    string result = "";
    result += "=== COMBAT STATUS ===\n";
    result += "Target: " + combat_target->query_cap_name() + "\n";
    result += "Round: " + combat_round + "\n";
    result += "Attacks used: " + attacks_this_round + "/" + max_attacks + "\n";
    result += "Your health: " + query_hp() + "/" + query_max_hp() + " HP";
    
    if (query_max_sdc() > 0) {
        result += ", " + query_sdc() + "/" + query_max_sdc() + " SDC";
    }
    
    result += "\nTarget health: ";
    int target_hp_pct = (combat_target->query_hp() * 100) / combat_target->query_max_hp();
    if (target_hp_pct >= 90) {
        result += "Healthy";
    } else if (target_hp_pct >= 70) {
        result += "Slightly wounded";
    } else if (target_hp_pct >= 40) {
        result += "Wounded";
    } else if (target_hp_pct >= 20) {
        result += "Badly wounded";
    } else {
        result += "Near death";
    }
    result += "\n";
    
    return result;
}

//=============================================================================
// NEW COMBAT SYSTEM - Phase 2
//=============================================================================

// Query number of attacks per round
int query_attacks_per_round() {
    int attacks = 1;  // Base: Everyone gets 1 attack
    
    // Add from race (if race object has this function)
    object race_ob = query_race_ob();
    if (race_ob && function_exists("query_attacks_per_round", race_ob)) {
        attacks += race_ob->query_attacks_per_round();
    }
    
    // Add from character level (high level characters get more attacks)
    if (level >= 5) attacks += 1;   // Level 5+: +1 attack
    if (level >= 10) attacks += 1;  // Level 10+: +2 attacks total
    if (level >= 15) attacks += 1;  // Level 15+: +3 attacks total
    
    return attacks;
}

// Query remaining attacks this round
int query_attacks_remaining() {
    int total = query_attacks_per_round();
    int used = attacks_this_round;
    int remaining = total - used;
    return remaining > 0 ? remaining : 0;
}

// Query combat archetype for verb selection
string query_combat_archetype() {
    // Check for wielded weapon first
    object weapon = query_wielded();
    if (weapon && function_exists("query_combat_archetype", weapon)) {
        return weapon->query_combat_archetype();
    }
    
    // Check race archetype
    object race_ob = query_race_ob();
    if (race_ob && function_exists("query_combat_archetype", race_ob)) {
        return race_ob->query_combat_archetype();
    }
    
    // Default to humanoid unarmed
    return "humanoid_unarmed";
}

// Query if character has auto-parry
int query_auto_parry() {
    // Check race for auto-parry
    object race_ob = query_race_ob();
    if (race_ob && function_exists("query_auto_parry", race_ob)) {
        if (race_ob->query_auto_parry()) return 1;
    }
    
    // Characters with Hand to Hand skill get auto-parry
    // (Will be improved when skill system is fully integrated)
    return 1;  // For now, everyone has auto-parry
}

// Query if character has auto-dodge
int query_auto_dodge() {
    // Check race for auto-dodge
    object race_ob = query_race_ob();
    if (race_ob && function_exists("query_auto_dodge", race_ob)) {
        if (race_ob->query_auto_dodge()) return 1;
    }
    
    // Everyone has auto-dodge by default
    return 1;
}

// Query parries per round
int query_parries_per_round() {
    int parries = 2;  // Base parries
    
    // Add from race
    object race_ob = query_race_ob();
    if (race_ob && function_exists("query_parries_per_round", race_ob)) {
        int race_parries = race_ob->query_parries_per_round();
        if (race_parries > 0) parries = race_parries;
    }
    
    // Add bonus from PP (every 3 points above 15)
    int pp = query_stat("PP");
    if (pp > 15) {
        parries += (pp - 15) / 3;
    }
    
    // Add from level
    if (level >= 8) parries += 1;
    if (level >= 12) parries += 1;
    
    return parries;
}

// Query parry bonus
int query_parry_bonus() {
    int bonus = 0;
    
    // PP bonus (every 3 points above 10)
    int pp = query_stat("PP");
    if (pp > 10) {
        bonus += (pp - 10) / 3;
    }
    
    // Level bonus
    bonus += level / 4;
    
    // Weapon parry bonus
    object weapon = query_wielded();
    if (weapon && function_exists("query_parry_bonus", weapon)) {
        bonus += weapon->query_parry_bonus();
    }
    
    return bonus;
}

// Query dodge bonus
int query_dodge_bonus() {
    int bonus = 0;
    
    // PP bonus (every 3 points above 10)
    int pp = query_stat("PP");
    if (pp > 10) {
        bonus += (pp - 10) / 3;
    }
    
    // SPD bonus (speed/agility, every 5 points above 10)
    int spd = query_stat("SPD");
    if (spd > 10) {
        bonus += (spd - 10) / 5;
    }
    
    // Level bonus
    bonus += level / 4;
    
    return bonus;
}

// Query damage type (SDC or MDC)
int query_damage_type() {
    // Check wielded weapon
    object weapon = query_wielded();
    if (weapon && function_exists("query_is_mega_damage", weapon)) {
        return weapon->query_is_mega_damage() ? 1 : 0;
    }
    
    // Check if MDC creature with natural MDC attacks
    if (health_type == 1) {
        // MDC creature - check if race has MDC natural attacks
        object race_ob = query_race_ob();
        if (race_ob && function_exists("query_mdc_natural_attacks", race_ob)) {
            if (race_ob->query_mdc_natural_attacks()) return 1;
        }
    }
    
    // Default to SDC damage
    return 0;
}

// Query wielded weapon
object query_wielded() {
    // Check equipment mapping
    mapping equipped = query_equipped();
    if (equipped && equipped["wielded"]) {
        return equipped["wielded"];
    }
    
    // No weapon yielded
    return 0;
}

// Query race object
object query_race_ob() {
    // This should return the race object
    // For now, try to load based on race_name
    if (race_name && race_name != "") {
        string race_path = "/races/" + lower_case(replace_string(race_name, " ", "_"));
        catch {
            return load_object(race_path);
        };
    }
    return 0;
}

// Query subjective pronoun (he/she/they/it)
string query_subjective() {
    // For players, check gender preference
    // For NPCs, default based on name or "it"
    // Simplified version for now
    if (interactive(this_object())) {
        // Player - try to get gender setting
        // For now, default to "they" (gender-neutral)
        return "they";
    } else {
        // NPC - default to "it"
        return "it";
    }
}
//=============================================================================
// Experience and Leveling System (Levels 0-15)
//=============================================================================

// Experience thresholds for levels 0-15
static int *exp_table = ({
    0,      // Level 0 (shouldn't happen)
    0,      // Level 1 (starting level)
    1000,   // Level 2
    2500,   // Level 3
    5000,   // Level 4
    10000,  // Level 5
    20000,  // Level 6
    35000,  // Level 7
    55000,  // Level 8
    80000,  // Level 9
    115000, // Level 10
    160000, // Level 11
    220000, // Level 12
    300000, // Level 13
    400000, // Level 14
    550000  // Level 15 (max level, super powerful and rare)
});

int query_exp() {
    return experience;
}

int query_exp_to_level() {
    if (level >= 15) return 0;  // Max level
    return exp_table[level + 1] - experience;
}

int query_exp_for_level(int lev) {
    if (lev < 1 || lev > 15) return 0;
    return exp_table[lev];
}

// Add experience and check for level up
void add_exp(int amount) {
    if (level >= 15) return;  // Max level reached
    
    experience += amount;
    
    // Check for level up
    while (level < 15 && experience >= exp_table[level + 1]) {
        level_up();
    }
}

// Level up the character
void level_up() {
    int old_level;
    
    old_level = level;
    level++;
    
    // Calculate lives gained:
    // - Levels 1-10: +1 life per level
    // - Levels 12, 14: +1 life (every 2 levels)
    // - Max lives caps at 15
    if (level <= 10) {
        lives++;
        max_lives++;
        tell_object(this_object(), "\n*** LEVEL UP! You are now level " + level + "! ***");
        tell_object(this_object(), "You gain 1 life! (Lives: " + lives + "/" + max_lives + ")\n");
    } else if (level == 12 || level == 14) {
        lives++;
        max_lives++;
        tell_object(this_object(), "\n*** LEVEL UP! You are now level " + level + "! ***");
        tell_object(this_object(), "You gain 1 life! (Lives: " + lives + "/" + max_lives + ")\n");
    } else {
        tell_object(this_object(), "\n*** LEVEL UP! You are now level " + level + "! ***\n");
    }
    
    // Notify room
    tell_room(environment(this_object()), 
              query_cap_name() + " has gained a level!",
              ({ this_object() }));
    
    // Increase stats slightly
    int hp_gain = random(6) + 5;  // 5-10 HP per level
    int sdc_gain = random(10) + 5; // 5-14 SDC per level
    
    max_hp += hp_gain;
    hp += hp_gain;
    
    if (health_type == 0) {  // SDC creature
        max_sdc += sdc_gain;
        sdc += sdc_gain;
        tell_object(this_object(), "HP +" + hp_gain + ", SDC +" + sdc_gain + "\n");
    } else {  // MDC creature
        int mdc_gain = random(10) + 10;  // 10-19 MDC per level
        max_mdc += mdc_gain;
        mdc += mdc_gain;
        tell_object(this_object(), "HP +" + hp_gain + ", MDC +" + mdc_gain + "\n");
    }
}

//=============================================================================
// Lives and Death System (Rifts style with scars and corpse recovery)
//=============================================================================

int query_lives() {
    return lives;
}

int query_max_lives() {
    return max_lives;
}

void set_lives(int num) {
    lives = num;
    if (lives > max_lives) lives = max_lives;
}

void add_lives(int num) {
    lives += num;
    if (lives > max_lives) lives = max_lives;
}

string *query_scars() {
    if (!scars) scars = ({});
    return scars;
}

void add_scar(string scar_desc) {
    if (!scars) scars = ({});
    scars += ({ scar_desc });
}

// Death handler - called when HP/MDC reaches 0
void die(object killer) {
    object corpse, death_room;
    string *scar_types;
    
    // Lose a life
    lives--;
    
    tell_object(this_object(), "\n*** YOU HAVE DIED! ***\n");
    
    if (lives <= 0) {
        // Permanent death - no more lives
        tell_object(this_object(), "You have no lives remaining!\n");
        tell_object(this_object(), "Your character is permanently dead.\n");
        // Could implement permadeath logic here
        // For now, just respawn with 1 life as a mercy
        lives = 1;
    }
    
    tell_object(this_object(), "Lives remaining: " + lives + "/" + max_lives + "\n");
    
    // Create corpse with player's items
    corpse = clone_object("/std/corpse");
    if (corpse) {
        corpse->set_corpse_name(query_name());
        corpse->set_property("corpse_owner", query_name());
        corpse->move(environment(this_object()));
        
        // Transfer items to corpse
        object *inv = all_inventory(this_object());
        if (inv && sizeof(inv) > 0) {
            foreach (object item : inv) {
                if (item && environment(item) == this_object()) {
                    item->move(corpse);
                }
            }
        }
    }
    
    // Notify room
    tell_room(environment(this_object()),
              query_cap_name() + " collapses to the ground, lifeless!",
              ({ this_object() }));
    
    // Add a random scar
    scar_types = ({
        "a jagged scar across your left cheek",
        "a deep scar on your right arm",
        "claw marks across your chest",
        "a burn scar on your shoulder",
        "a puncture wound scar on your leg",
        "blade scars across your back",
        "a scarred left hand from severe trauma",
        "burn marks covering your forearms"
    });
    
    add_scar(scar_types[random(sizeof(scar_types))]);
    
    // Move to death/recovery room
    death_room = load_object("/domains/death/recovery_room");
    if (death_room) {
        move(death_room);
        tell_object(this_object(), "\n");
        // Room will describe the recovery
    } else {
        // Fallback if death room doesn't exist
        tell_object(this_object(), "\nYou awaken in a haze, patched up but bearing a new scar: " + scars[sizeof(scars)-1] + "\n");
    }
    
    // Restore some health
    if (health_type == 0) {  // SDC creature
        hp = max_hp / 2;
        sdc = max_sdc / 2;
    } else {  // MDC creature
        mdc = max_mdc / 2;
    }
    
    // End combat
    if (combat_target) {
        set_combat_target(0);
    }
}

// ==================== CURRENCY SYSTEM ====================

int query_universal_credits() {
    return universal_credits;
}

int query_black_market_credits() {
    return black_market_credits;
}

int query_credits() {
    return universal_credits;  // Default to UC
}

void set_universal_credits(int amount) {
    if (amount < 0) amount = 0;
    universal_credits = amount;
}

void set_black_market_credits(int amount) {
    if (amount < 0) amount = 0;
    black_market_credits = amount;
}

void add_universal_credits(int amount) {
    universal_credits += amount;
    if (universal_credits < 0) universal_credits = 0;
}

void add_black_market_credits(int amount) {
    black_market_credits += amount;
    if (black_market_credits < 0) black_market_credits = 0;
}

int remove_universal_credits(int amount) {
    if (universal_credits < amount) {
        return 0;  // Not enough credits
    }
    universal_credits -= amount;
    return 1;  // Success
}

int remove_black_market_credits(int amount) {
    if (black_market_credits < amount) {
        return 0;  // Not enough credits
    }
    black_market_credits -= amount;
    return 1;  // Success
}

// Transfer credits between players/NPCs
int transfer_credits(object target, int amount, int type) {
    if (!target) return 0;
    if (amount <= 0) return 0;
    
    if (type == 0) {  // Universal credits
        if (universal_credits < amount) return 0;
        universal_credits -= amount;
        target->add_universal_credits(amount);
        return 1;
    } else {  // Black market credits
        if (black_market_credits < amount) return 0;
        black_market_credits -= amount;
        target->add_black_market_credits(amount);
        return 1;
    }
}
