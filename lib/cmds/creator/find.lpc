/*
 * /lib/cmds/creator/find.lpc - Find files by name pattern
 * Phase 2: Essential Creator Filesystem Commands
 * 
 * Usage:
 *   find <directory>                   List all files recursively
 *   find <directory> -name <pattern>   Find files matching pattern
 *   find <directory> -type f           Find only files
 *   find <directory> -type d           Find only directories
 */

int main(string args) {
    object player = previous_object();
    string directory, name_pattern;
    string *parts;
    int i, type_filter = 0; // 0=all, 1=files, 2=dirs
    int match_count = 0;
    
    if (!args || args == "") {
        tell_object(player, "Syntax: find <directory> [-name <pattern>] [-type f|d]\n");
        tell_object(player, "Options:\n");
        tell_object(player, "  -name <pattern>  Find files matching pattern (supports * wildcard)\n");
        tell_object(player, "  -type f          Find only files\n");
        tell_object(player, "  -type d          Find only directories\n");
        return 1;
    }
    
    // Parse arguments
    parts = explode(args, " ") - ({ "" });
    if (sizeof(parts) < 1) {
        tell_object(player, "Error: Missing directory\n");
        return 1;
    }
    
    directory = parts[0];
    name_pattern = 0;
    
    // Parse options
    i = 1;
    while (i < sizeof(parts)) {
        if (parts[i] == "-name") {
            if (i + 1 >= sizeof(parts)) {
                tell_object(player, "Error: -name requires a pattern argument\n");
                return 1;
            }
            name_pattern = parts[i + 1];
            i += 2;
        } else if (parts[i] == "-type") {
            if (i + 1 >= sizeof(parts)) {
                tell_object(player, "Error: -type requires f or d argument\n");
                return 1;
            }
            if (parts[i + 1] == "f") {
                type_filter = 1;
            } else if (parts[i + 1] == "d") {
                type_filter = 2;
            } else {
                tell_object(player, "Error: -type must be 'f' (file) or 'd' (directory)\n");
                return 1;
            }
            i += 2;
        } else {
            tell_object(player, "Error: Unknown option: " + parts[i] + "\n");
            return 1;
        }
    }
    
    // Resolve directory path
    string resolved = player->resolve_path(directory);
    
    // Check if directory exists
    if (file_size(resolved) != -2) {
        tell_object(player, "Error: Directory not found: " + resolved + "\n");
        return 1;
    }
    
    tell_object(player, "Searching: " + resolved + "\n");
    if (name_pattern) {
        tell_object(player, "Pattern: " + name_pattern + "\n");
    }
    tell_object(player, "\n");
    
    // Start recursive search
    match_count = find_recursive(player, resolved, name_pattern, type_filter);
    
    tell_object(player, sprintf("\nFound %d match%s.\n", match_count, match_count == 1 ? "" : "es"));
    
    return 1;
}

// Recursively search directory
int find_recursive(object player, string dir, string pattern, int type_filter) {
    string *entries;
    int i, match_count = 0;
    
    entries = get_dir(dir + "/*");
    if (!entries) return 0;
    
    for (i = 0; i < sizeof(entries); i++) {
        string full_path = dir + "/" + entries[i];
        int fsize = file_size(full_path);
        int is_dir = (fsize == -2);
        
        // Check if this entry matches our criteria
        int matches = 0;
        
        // Type filter check
        if (type_filter == 0 || (type_filter == 1 && !is_dir) || (type_filter == 2 && is_dir)) {
            // Name pattern check
            if (!pattern || wildcard_match(entries[i], pattern)) {
                matches = 1;
            }
        }
        
        // Print if it matches
        if (matches) {
            tell_object(player, full_path + (is_dir ? "/" : "") + "\n");
            match_count++;
        }
        
        // Recurse into directories
        if (is_dir) {
            match_count += find_recursive(player, full_path, pattern, type_filter);
        }
    }
    
    return match_count;
}

// Simple wildcard matching for * patterns
int wildcard_match(string str, string pattern) {
    int star_pos;
    
    // No wildcard - exact match
    if (strsrch(pattern, "*") == -1) {
        return str == pattern;
    }
    
    // Handle leading wildcard: *.lpc
    if (pattern[0] == '*') {
        string suffix = pattern[1..];
        int str_len = strlen(str);
        int suffix_len = strlen(suffix);
        if (str_len >= suffix_len) {
            return str[str_len - suffix_len..] == suffix;
        }
        return 0;
    }
    
    // Handle trailing wildcard: test*
    star_pos = strsrch(pattern, "*");
    if (star_pos == strlen(pattern) - 1) {
        string prefix = pattern[0..star_pos-1];
        if (strlen(str) >= strlen(prefix)) {
            return str[0..strlen(prefix)-1] == prefix;
        }
        return 0;
    }
    
    // Handle middle wildcard: test*.lpc
    string before = pattern[0..star_pos-1];
    string after = pattern[star_pos+1..];
    
    if (strlen(str) >= strlen(before) + strlen(after)) {
        if (str[0..strlen(before)-1] == before) {
            int str_len = strlen(str);
            int after_len = strlen(after);
            if (str[str_len - after_len..] == after) {
                return 1;
            }
        }
    }
    
    return 0;
}

void help() {
    write("Syntax: find <directory> [-name <pattern>] [-type f|d]\n");
    write("Find files and directories recursively.\n");
    write("\n");
    write("Options:\n");
    write("  -name <pattern>  Match files by name (supports * wildcard)\n");
    write("  -type f          Find only files\n");
    write("  -type d          Find only directories\n");
    write("\n");
    write("Examples:\n");
    write("  find /lib/std                    List all files in /lib/std\n");
    write("  find /lib/cmds -name *.lpc       Find all .lpc files\n");
    write("  find /lib -name room.lpc         Find files named room.lpc\n");
    write("  find /domains -type d            Find all directories\n");
    write("  find /lib/cmds -name test*       Find files starting with 'test'\n");
    write("\n");
    write("See also: grep, ls\n");
}
