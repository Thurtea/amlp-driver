# Phase 2: Virtual Machine Architecture

## Overview
Complete bytecode-based stack VM for executing LPC programs compiled from AST.

## File Structure

### vm.h (497 lines, 14KB)
**Complete bytecode system with:**

#### Opcodes (50+ instructions)
- **Stack**: `PUSH_INT`, `PUSH_FLOAT`, `PUSH_STRING`, `PUSH_NULL`, `POP`, `DUP`
- **Variables**: `LOAD_LOCAL`, `STORE_LOCAL`, `LOAD_GLOBAL`, `STORE_GLOBAL`
- **Arithmetic**: `ADD`, `SUB`, `MUL`, `DIV`, `MOD`, `NEG`
- **Comparison**: `EQ`, `NE`, `LT`, `LE`, `GT`, `GE`
- **Logical**: `AND`, `OR`, `NOT`
- **Bitwise**: `BIT_AND`, `BIT_OR`, `BIT_XOR`, `BIT_NOT`, `LSHIFT`, `RSHIFT`
- **Control Flow**: `JUMP`, `JUMP_IF_FALSE`, `JUMP_IF_TRUE`
- **Functions**: `CALL`, `RETURN`
- **Arrays**: `MAKE_ARRAY`, `INDEX_ARRAY`, `STORE_ARRAY`
- **Mappings**: `MAKE_MAPPING`, `INDEX_MAPPING`, `STORE_MAPPING`
- **Objects**: `CALL_METHOD`
- **Special**: `HALT`, `PRINT`

#### Data Structures
```c
VMValue         // Tagged union for all LPC types (int, float, string, etc.)
VMArray         // Dynamic array with capacity management
VMMapping       // Hash table with collision chaining
VMInstruction   // Opcode + operand union
VMFunction      // Bytecode function with params, locals, instructions
CallFrame       // Execution frame with locals, IP, stack base
VirtualMachine  // Main VM: stack, functions, globals, string pool
```

#### API (40+ functions)
- VM lifecycle: `vm_init()`, `vm_free()`, `vm_execute()`
- Bytecode loading: `vm_load_bytecode()`, `vm_add_function()`
- Stack ops: `vm_push_value()`, `vm_pop_value()`, `vm_peek_value()`
- Value creation: `vm_value_create_int/float/string/null()`
- Arrays: `vm_array_create/push/get/set/free()`
- Mappings: `vm_mapping_create/set/get/free()`
- Functions: `vm_function_create/add_instruction/free()`
- Debugging: `vm_print_stack()`, `vm_disassemble_instruction/function()`

### codegen.h (316 lines, 7.8KB)
**AST-to-bytecode compiler with:**

#### Symbol Management
```c
Symbol          // Name, type, index, scope depth
SymbolTable     // Hash table with parent chain for nested scopes
```

#### Label Management
```c
Label           // Name, address, patch locations for forward jumps
```

#### Code Generator
```c
CodeGenerator   // VM ref, symbol table, current function, labels, loop context
```

#### API (25+ functions)
- Compilation: `codegen_compile()`, `codegen_compile_statement/expression/function()`
- Emission: `codegen_emit()`, `codegen_emit_opcode/int/float/string()`
- Patching: `codegen_patch_address()`
- Symbols: `symbol_table_create/add/lookup/free()`
- Labels: `codegen_create_label()`, `codegen_mark_label()`, `codegen_emit_jump()`

## Implementation Plan

### Step 1: vm.c Implementation [DONE] NEXT
Core execution engine with:
- Stack operations
- Value type handling
- Instruction dispatch loop
- Array/mapping operations
- Function call mechanism

### Step 2: codegen.c Implementation
AST traversal and bytecode emission:
- Expression compilation (literals, variables, binary ops, function calls)
- Statement compilation (declarations, assignments, control flow)
- Function definition handling
- Symbol table management
- Label resolution

### Step 3: test_vm.c
Comprehensive VM tests:
- Stack operations (push, pop, arithmetic)
- Variable storage (local, global)
- Control flow (jumps, conditionals)
- Function calls and returns
- Array operations
- Mapping operations
- End-to-end bytecode execution

### Step 4: Makefile Integration
Add new targets:
- `vm.o`, `codegen.o` compilation
- `test_vm` executable
- Link with existing lexer/parser

### Step 5: Integration Testing
- Compile simple LPC programs
- Verify bytecode generation
- Execute and validate results
- Performance benchmarking

## Execution Flow

```
Source Code
    ?
Lexer (tokens)
    ?
Parser (AST)
    ?
CodeGen (bytecode)
    ?
VM (execution)
    ?
Result
```

## Example Bytecode

LPC source:
```lpc
int add(int a, int b) {
    return a + b;
}

int main() {
    return add(5, 3);
}
```

Generated bytecode:
```
Function: add (params=2, locals=0)
  0: LOAD_LOCAL 0      // load 'a'
  1: LOAD_LOCAL 1      // load 'b'
  2: ADD               // a + b
  3: RETURN            // return result

Function: main (params=0, locals=0)
  0: PUSH_INT 5        // first argument
  1: PUSH_INT 3        // second argument
  2: CALL 0, 2         // call add with 2 args
  3: RETURN            // return result
```

## Memory Management

- **Stack**: Pre-allocated array with overflow checking
- **Strings**: Pooled to avoid duplication, reference counted
- **Arrays**: Dynamic with capacity doubling
- **Mappings**: Hash table with load factor management
- **Call Frames**: Linked list allocation on demand

## Status
- [DONE] vm.h complete (497 lines)
- [DONE] codegen.h complete (316 lines)
- [IN PROGRESS] vm.c implementation in progress
- [IN PROGRESS] codegen.c implementation pending
- [IN PROGRESS] test_vm.c pending
- [IN PROGRESS] Makefile integration pending

## Next Steps
1. Implement vm.c with full execution engine (~800 lines)
2. Implement codegen.c with AST compilation (~1000 lines)
3. Create test_vm.c with comprehensive tests (~400 lines)
4. Update Makefile
5. Build and validate entire system
