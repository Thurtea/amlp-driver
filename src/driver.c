/*
 * driver.c - Main LPC MUD Driver CLI
 * 
 * This file serves as the command-line interface for the LPC MUD driver.
 * 
 * Commands:
 *   ./driver compile <file.c>   - Compile and show success/errors
 *   ./driver ast <file.c>        - Show parsed AST
 *   ./driver bytecode <file.c>   - Show generated bytecode
 *   ./driver run <file.c>        - Compile and execute bytecode
 *   ./driver help                - Show usage information
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "lexer.h"
#include "parser.h"
#include "compiler.h"
#include "vm.h"
#include "program_loader.h"
#include "master_object.h"

typedef struct {
    VirtualMachine *vm;
    int master_loaded;
} DriverContext;

static DriverContext *g_driver_ctx = NULL;

static void driver_cleanup(void) {
    if (g_driver_ctx) {
        if (g_driver_ctx->master_loaded) {
            master_object_free();
        }
        if (g_driver_ctx->vm) {
            vm_free(g_driver_ctx->vm);
        }
        free(g_driver_ctx);
    }
}

/* ========== Utility Functions ========== */

/**
 * Read file contents into a string
 */
static char* read_file_contents(const char *filename) {
    FILE *fp = fopen(filename, "r");
    if (!fp) {
        fprintf(stderr, "Error: Cannot open file '%s'\n", filename);
        return NULL;
    }
    
    fseek(fp, 0, SEEK_END);
    long size = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    
    char *buffer = (char *)malloc(size + 1);
    if (!buffer) {
        fclose(fp);
        return NULL;
    }
    
    size_t read_size = fread(buffer, 1, size, fp);
    buffer[read_size] = '\0';
    fclose(fp);
    
    return buffer;
}

/**
 * Print AST node recursively
 */
static void print_ast_node(ASTNode *node, int indent) {
    if (!node) return;
    
    for (int i = 0; i < indent; i++) printf("  ");
    
    switch (node->type) {
        case NODE_PROGRAM: {
            printf("PROGRAM\n");
            ProgramNode *prog = (ProgramNode *)node->data;
            if (prog) {
                for (int i = 0; i < prog->declaration_count; i++) {
                    print_ast_node(prog->declarations[i], indent + 1);
                }
            }
            break;
        }
            
        case NODE_FUNCTION_DECL: {
            FunctionDeclNode *func = (FunctionDeclNode *)node->data;
            if (func) {
                printf("FUNCTION: %s (args: %d)\n", 
                       func->name,
                       func->parameter_count);
                print_ast_node(func->body, indent + 1);
            }
            break;
        }
            
        case NODE_VARIABLE_DECL: {
            VariableDeclNode *var = (VariableDeclNode *)node->data;
            if (var) {
                printf("VARIABLE: %s\n", var->name);
                if (var->initializer) {
                    print_ast_node(var->initializer, indent + 1);
                }
            }
            break;
        }
            
        case NODE_BLOCK: {
            printf("BLOCK\n");
            BlockNode *block = (BlockNode *)node->data;
            if (block) {
                for (int i = 0; i < block->statement_count; i++) {
                    print_ast_node(block->statements[i], indent + 1);
                }
            }
            break;
        }
            
        case NODE_RETURN_STATEMENT: {
            printf("RETURN\n");
            ReturnStatementNode *ret = (ReturnStatementNode *)node->data;
            if (ret && ret->value) {
                print_ast_node(ret->value, indent + 1);
            }
            break;
        }
            
        case NODE_IF_STATEMENT: {
            printf("IF\n");
            IfStatementNode *if_stmt = (IfStatementNode *)node->data;
            if (if_stmt) {
                for (int i = 0; i < indent + 1; i++) printf("  ");
                printf("condition:\n");
                print_ast_node(if_stmt->condition, indent + 2);
                for (int i = 0; i < indent + 1; i++) printf("  ");
                printf("then:\n");
                print_ast_node(if_stmt->then_statement, indent + 2);
                if (if_stmt->else_statement) {
                    for (int i = 0; i < indent + 1; i++) printf("  ");
                    printf("else:\n");
                    print_ast_node(if_stmt->else_statement, indent + 2);
                }
            }
            break;
        }
            
        case NODE_BINARY_OP: {
            BinaryOpNode *binop = (BinaryOpNode *)node->data;
            if (binop) {
                printf("BINARY_OP: %s\n", binop->operator);
                print_ast_node(binop->left, indent + 1);
                print_ast_node(binop->right, indent + 1);
            }
            break;
        }
            
        case NODE_UNARY_OP: {
            UnaryOpNode *unop = (UnaryOpNode *)node->data;
            if (unop) {
                printf("UNARY_OP: %s\n", unop->operator);
                print_ast_node(unop->operand, indent + 1);
            }
            break;
        }
            
        case NODE_LITERAL_NUMBER: {
            LiteralNumberNode *num = (LiteralNumberNode *)node->data;
            if (num) {
                if (num->is_float) {
                    printf("LITERAL: %.2f\n", num->float_value);
                } else {
                    printf("LITERAL: %ld\n", num->int_value);
                }
            }
            break;
        }
            
        case NODE_LITERAL_STRING: {
            LiteralStringNode *str = (LiteralStringNode *)node->data;
            if (str) {
                printf("LITERAL: \"%s\"\n", str->value);
            }
            break;
        }
            
        case NODE_IDENTIFIER: {
            IdentifierNode *id = (IdentifierNode *)node->data;
            if (id) {
                printf("IDENTIFIER: %s\n", id->name);
            }
            break;
        }
            
        case NODE_FUNCTION_CALL: {
            FunctionCallNode *call = (FunctionCallNode *)node->data;
            if (call) {
                printf("CALL: %s (args: %d)\n", 
                       call->function_name,
                       call->argument_count);
                for (int i = 0; i < call->argument_count; i++) {
                    print_ast_node(call->arguments[i], indent + 1);
                }
            }
            break;
        }
            
        case NODE_EXPRESSION_STATEMENT: {
            printf("EXPRESSION_STMT\n");
            ASTNode *expr = (ASTNode *)node->data;
            if (expr) {
                print_ast_node(expr, indent + 1);
            }
            break;
        }
            
        default:
            printf("UNKNOWN_NODE (type %d)\n", node->type);
            break;
    }
}

/**
 * Disassemble bytecode
 */
static void disassemble_bytecode(uint8_t *bytecode, size_t length) {
    printf("\nBytecode (%zu bytes):\n", length);
    printf("Offset  Opcode           Operand\n");
    printf("------  ---------------  ------------------\n");
    
    size_t i = 0;
    while (i < length) {
        printf("%04zx    ", i);
        
        OpCode opcode = (OpCode)bytecode[i];
        i++;
        
        switch (opcode) {
            case OP_PUSH_INT:
                printf("PUSH_INT         ");
                if (i + 8 <= length) {
                    int64_t val = 0;
                    for (int j = 0; j < 8; j++) {
                        val |= ((int64_t)bytecode[i + j]) << (j * 8);
                    }
                    printf("%ld", (long)val);
                    i += 8;
                }
                break;
                
            case OP_PUSH_FLOAT:
                printf("PUSH_FLOAT       ");
                if (i + 8 <= length) {
                    union { uint8_t bytes[8]; double dval; } u;
                    for (int j = 0; j < 8; j++) {
                        u.bytes[j] = bytecode[i + j];
                    }
                    printf("%.2f", u.dval);
                    i += 8;
                }
                break;
                
            case OP_PUSH_STRING:
                printf("PUSH_STRING      ");
                if (i + 8 <= length) {
                    int64_t idx = 0;
                    for (int j = 0; j < 8; j++) {
                        idx |= ((int64_t)bytecode[i + j]) << (j * 8);
                    }
                    printf("#%ld", (long)idx);
                    i += 8;
                }
                break;
                
            case OP_PUSH_NULL:
                printf("PUSH_NULL");
                break;
                
            case OP_LOAD_GLOBAL:
                printf("LOAD_GLOBAL");
                break;
                
            case OP_STORE_GLOBAL:
                printf("STORE_GLOBAL");
                break;
                
            case OP_ADD:
                printf("ADD");
                break;
                
            case OP_SUB:
                printf("SUB");
                break;
                
            case OP_MUL:
                printf("MUL");
                break;
                
            case OP_DIV:
                printf("DIV");
                break;
                
            case OP_MOD:
                printf("MOD");
                break;
                
            case OP_NEG:
                printf("NEG");
                break;
                
            case OP_NOT:
                printf("NOT");
                break;
                
            case OP_EQ:
                printf("EQ");
                break;
                
            case OP_NE:
                printf("NE");
                break;
                
            case OP_LT:
                printf("LT");
                break;
                
            case OP_GT:
                printf("GT");
                break;
                
            case OP_LE:
                printf("LE");
                break;
                
            case OP_GE:
                printf("GE");
                break;
                
            case OP_AND:
                printf("AND");
                break;
                
            case OP_OR:
                printf("OR");
                break;
                
            case OP_JUMP:
                printf("JUMP             ");
                if (i + 8 <= length) {
                    int64_t addr = 0;
                    for (int j = 0; j < 8; j++) {
                        addr |= ((int64_t)bytecode[i + j]) << (j * 8);
                    }
                    printf("‚Üí %04lx", (long)addr);
                    i += 8;
                }
                break;
                
            case OP_JUMP_IF_FALSE:
                printf("JUMP_IF_FALSE    ");
                if (i + 8 <= length) {
                    int64_t addr = 0;
                    for (int j = 0; j < 8; j++) {
                        addr |= ((int64_t)bytecode[i + j]) << (j * 8);
                    }
                    printf("‚Üí %04lx", (long)addr);
                    i += 8;
                }
                break;
                
            case OP_CALL:
                printf("CALL             ");
                if (i + 8 <= length) {
                    int64_t argc = 0;
                    for (int j = 0; j < 8; j++) {
                        argc |= ((int64_t)bytecode[i + j]) << (j * 8);
                    }
                    printf("(args: %ld)", (long)argc);
                    i += 8;
                }
                break;
                
            case OP_RETURN:
                printf("RETURN");
                break;
                
            case OP_POP:
                printf("POP");
                break;
                
            default:
                printf("UNKNOWN_OP_%02x", opcode);
                break;
        }
        
        printf("\n");
    }
}

/* ========== Command Handlers ========== */

/**
 * Command: compile <file.c>
 */
static int cmd_compile(const char *filename) {
    printf("Compiling: %s\n", filename);
    printf("========================================\n\n");
    
    Program *prog = compiler_compile_file(filename);
    if (!prog) {
        fprintf(stderr, "Error: Failed to compile file\n");
        return 1;
    }
    
    if (prog->last_error != COMPILE_SUCCESS) {
        printf("‚ùå Compilation FAILED\n\n");
        printf("Error: %s\n", compiler_error_string(prog->last_error));
        if (prog->error_info.message) {
            printf("  %s:%d:%d: %s\n",
                   prog->error_info.filename,
                   prog->error_info.line,
                   prog->error_info.column,
                   prog->error_info.message);
        }
        program_free(prog);
        return 1;
    }
    
    printf("‚úÖ Compilation SUCCESSFUL\n\n");
    
    printf("Program Information:\n");
    printf("  File:      %s\n", prog->filename);
    printf("  Bytecode:  %zu bytes\n", prog->bytecode_len);
    printf("  Functions: %zu\n", prog->function_count);
    printf("  Globals:   %zu\n", prog->global_count);
    printf("\n");
    
    if (prog->function_count > 0) {
        printf("Functions:\n");
        for (size_t i = 0; i < prog->function_count; i++) {
            printf("  [%zu] %s (args: %d, locals: %d, offset: 0x%04x)\n",
                   i,
                   prog->functions[i].name,
                   prog->functions[i].arg_count,
                   prog->functions[i].local_count,
                   prog->functions[i].offset);
        }
        printf("\n");
    }
    
    if (prog->global_count > 0) {
        printf("Global Variables:\n");
        for (size_t i = 0; i < prog->global_count; i++) {
            printf("  %s = ", prog->globals[i].name);
            if (prog->globals[i].value.type == VALUE_INT) {
                printf("%ld\n", prog->globals[i].value.data.int_value);
            } else if (prog->globals[i].value.type == VALUE_NULL) {
                printf("null\n");
            } else {
                printf("(type %d)\n", prog->globals[i].value.type);
            }
        }
        printf("\n");
    }
    
    program_free(prog);
    return 0;
}

/**
 * Command: ast <file.c>
 */
static int cmd_ast(const char *filename) {
    printf("Parsing AST: %s\n", filename);
    printf("========================================\n\n");
    
    char *source = read_file_contents(filename);
    if (!source) {
        return 1;
    }
    
    Lexer *lexer = lexer_init_from_string(source);
    if (!lexer) {
        fprintf(stderr, "Error: Failed to initialize lexer\n");
        free(source);
        return 1;
    }
    
    Parser *parser = parser_init(lexer);
    if (!parser) {
        fprintf(stderr, "Error: Failed to initialize parser\n");
        lexer_free(lexer);
        free(source);
        return 1;
    }
    
    ASTNode *ast = parser_parse(parser);
    
    if (parser->error_count > 0) {
        printf("‚ùå Parsing FAILED with %d errors\n\n", parser->error_count);
        fprintf(stderr, "  %s: Parse errors detected\n", filename);
        ast_node_free(ast);
        parser_free(parser);
        lexer_free(lexer);
        free(source);
        return 1;
    }
    
    printf("‚úÖ Parsing SUCCESSFUL\n\n");
    printf("Abstract Syntax Tree:\n");
    printf("----------------------------------------\n");
    print_ast_node(ast, 0);
    printf("\n");
    
    ast_node_free(ast);
    parser_free(parser);
    lexer_free(lexer);
    free(source);
    return 0;
}

/**
 * Command: bytecode <file.c>
 */
static int cmd_bytecode(const char *filename) {
    printf("Generating bytecode: %s\n", filename);
    printf("========================================\n\n");
    
    Program *prog = compiler_compile_file(filename);
    if (!prog) {
        fprintf(stderr, "Error: Failed to compile file\n");
        return 1;
    }
    
    if (prog->last_error != COMPILE_SUCCESS) {
        printf("‚ùå Compilation FAILED\n\n");
        compiler_print_error(prog);
        program_free(prog);
        return 1;
    }
    
    printf("‚úÖ Compilation SUCCESSFUL\n");
    disassemble_bytecode(prog->bytecode, prog->bytecode_len);
    
    printf("\nFunction Table:\n");
    for (size_t i = 0; i < prog->function_count; i++) {
        printf("  [%zu] %s @ offset 0x%04x\n",
               i,
               prog->functions[i].name,
               prog->functions[i].offset);
    }
    printf("\n");
    
    program_free(prog);
    return 0;
}

/**
 * Command: run <file.c>
 */
static int cmd_run(const char *filename) {
    printf("Running: %s\n", filename);
    printf("========================================\n\n");
    
    /* Step 1: Compile the file */
    Program *prog = compiler_compile_file(filename);
    if (!prog) {
        fprintf(stderr, "Error: Failed to compile file\n");
        return 1;
    }
    
    if (prog->last_error != COMPILE_SUCCESS) {
        printf("‚ùå Compilation FAILED\n\n");
        compiler_print_error(prog);
        program_free(prog);
        return 1;
    }
    
    printf("‚úÖ Compilation SUCCESSFUL\n\n");
    
    /* Step 2: Initialize VM */
    VirtualMachine *vm = vm_init();
    if (!vm) {
        fprintf(stderr, "Error: Failed to initialize VM\n");
        program_free(prog);
        return 1;
    }
    
    /* Step 3: Load program into VM */
    printf("Loading program into VM...\n");
    if (program_loader_load(vm, prog) != 0) {
        fprintf(stderr, "Error: Failed to load program into VM\n");
        vm_free(vm);
        program_free(prog);
        return 1;
    }
    
    printf("‚úÖ Program loaded\n\n");
    
    printf("\nüöÄ Executing...\n");
    printf("========================================\n\n");
    
    /* Find and call the create() function if it exists */
    int create_func_idx = -1;
    for (int i = 0; i < vm->function_count; i++) {
        if (vm->functions[i] && strcmp(vm->functions[i]->name, "create") == 0) {
            create_func_idx = i;
            break;
        }
    }
    
    int result = 0;
    if (create_func_idx >= 0) {
        printf("[Driver] Calling create() function...\n");
        result = vm_call_function(vm, create_func_idx, 0);
    } else {
        printf("[Driver] No create() function found, executing top-level code...\n");
        result = vm_execute(vm);
    }
    
    printf("\n========================================\n");
    if (result == 0) {
        printf("‚úÖ Execution COMPLETED successfully\n");
        
        /* Show final stack and globals for quick inspection */
        if (vm->stack && vm->stack->top > 0) {
            printf("\nFinal Stack State:\n");
            vm_print_stack(vm);
        }
        if (vm->global_count > 0 && vm->global_variables) {
            printf("\nGlobal Variables:\n");
            for (int i = 0; i < vm->global_count; i++) {
                char *val_str = vm_value_to_string(vm->global_variables[i]);
                printf("  [%d] = %s\n", i, val_str);
                free(val_str);
            }
        }
    } else {
        printf("‚ùå Execution FAILED with error code %d\n", result);
    }
    
    /* Step 5: Cleanup */
    vm_free(vm);
    program_free(prog);
    
    return 0;
}

/**
 * Show usage information
 */
static void show_usage(const char *program_name) {
    printf("AMLP Driver - LPC MUD Compiler\n");
    printf("Usage: %s <command> [arguments]\n\n", program_name);
    printf("Commands:\n");
    printf("  compile <file.c>     Compile LPC file and show results\n");
    printf("  ast <file.c>         Parse and display Abstract Syntax Tree\n");
    printf("  bytecode <file.c>    Compile and disassemble bytecode\n");
    printf("  run <file.c>         Compile and execute bytecode\n");
    printf("  load_master <file.c> Load master object for persistent VM\n");
    printf("  test_master          Test loaded master object\n");
    printf("  interactive          Enter interactive mode\n");
    printf("  help                 Show this help message\n");
    printf("\n");
    printf("Examples:\n");
    printf("  %s compile tests/lpc/hello.c\n", program_name);
    printf("  %s load_master /home/thurtea/amlp-library/master.c\n", program_name);
    printf("  %s test_master\n", program_name);
    printf("  %s interactive\n", program_name);
    printf("\n");
}

/* ========== Main Entry Point ========== */

int main(int argc, char *argv[]) {
    // Initialize driver context
    g_driver_ctx = calloc(1, sizeof(DriverContext));
    if (!g_driver_ctx) {
        fprintf(stderr, "Failed to allocate driver context\n");
        return 1;
    }
    
    g_driver_ctx->vm = vm_init();
    if (!g_driver_ctx->vm) {
        fprintf(stderr, "Failed to initialize VM\n");
        free(g_driver_ctx);
        return 1;
    }
    
    g_driver_ctx->master_loaded = 0;
    atexit(driver_cleanup);

    if (argc < 2) {
        show_usage(argv[0]);
        return 1;
    }
    
    const char *command = argv[1];
    
    if (strcmp(command, "help") == 0 || strcmp(command, "--help") == 0 || strcmp(command, "-h") == 0) {
        show_usage(argv[0]);
        return 0;
    }
    
    // Master object command handlers
    if (strcmp(command, "load_master") == 0) {
        if (argc < 3) {
            fprintf(stderr, "Usage: %s load_master <master_file.c>\n", argv[0]);
            return 1;
        }
        
        if (master_object_init(argv[2], g_driver_ctx->vm) == 0) {
            g_driver_ctx->master_loaded = 1;
            printf("Master object loaded successfully from: %s\n", argv[2]);
            return 0;
        } else {
            fprintf(stderr, "Failed to load master object from: %s\n", argv[2]);
            return 1;
        }
    }
    
    if (strcmp(command, "test_master") == 0) {
        if (!g_driver_ctx->master_loaded) {
            fprintf(stderr, "No master object loaded. Use 'load_master' first.\n");
            return 1;
        }
        
        printf("Master object is loaded and ready\n");
        VMValue args[1];
        VMValue result = master_call("create", args, 0);
        (void)result; // Mark unused
        printf("Called master create() function\n");
        return 0;
    }
    
    if (strcmp(command, "interactive") == 0) {
        printf("AMLP Interactive Mode\n");
        printf("Commands: load_master <file>, test_master, quit\n");
        
        char input[1024];
        while (printf("> ") && fgets(input, sizeof(input), stdin)) {
            // Remove newline
            input[strcspn(input, "\n")] = 0;
            
            if (strcmp(input, "quit") == 0) {
                break;
            } else if (strncmp(input, "load_master ", 12) == 0) {
                char *filename = input + 12;
                if (master_object_init(filename, g_driver_ctx->vm) == 0) {
                    g_driver_ctx->master_loaded = 1;
                    printf("Master loaded: %s\n", filename);
                } else {
                    printf("Failed to load: %s\n", filename);
                }
            } else if (strcmp(input, "test_master") == 0) {
                if (g_driver_ctx->master_loaded) {
                    printf("Master is ready\n");
                } else {
                    printf("No master loaded\n");
                }
            } else {
                printf("Unknown command: %s\n", input);
            }
        }
        return 0;
    }
    
    if (argc < 3) {
        fprintf(stderr, "Error: Missing filename argument\n");
        fprintf(stderr, "Try '%s help' for usage information\n", argv[0]);
        return 1;
    }
    
    const char *filename = argv[2];
    
    if (strcmp(command, "compile") == 0) {
        return cmd_compile(filename);
    } else if (strcmp(command, "ast") == 0) {
        return cmd_ast(filename);
    } else if (strcmp(command, "bytecode") == 0) {
        return cmd_bytecode(filename);
    } else if (strcmp(command, "run") == 0) {
        return cmd_run(filename);
    } else {
        fprintf(stderr, "Error: Unknown command '%s'\n", command);
        fprintf(stderr, "Try '%s help' for usage information\n", argv[0]);
        return 1;
    }
}
